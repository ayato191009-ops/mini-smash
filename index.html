<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Mini Smash Complete</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body{margin:0;background:#111;touch-action:none;}
canvas{background:#222;display:block;margin:auto;}
.ui{
  position:fixed;bottom:10px;left:0;right:0;
  display:flex;justify-content:space-between;padding:0 20px;
}
.left,.right{display:flex;gap:10px;}
button{
  width:64px;height:64px;border-radius:50%;
  font-size:18px;opacity:0.8;
}
</style>
</head>
<body>

<canvas id="game" width="360" height="240"></canvas>

<div class="ui">
  <div class="left">
    <button id="left">◀</button>
    <button id="up">⬆</button>
    <button id="right">▶</button>
  </div>
  <div class="right">
    <button id="a">A</button>
    <button id="b">B</button>
  </div>
</div>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

// キー＆タッチ管理
const keyState={};
document.addEventListener("keydown",e=>keyState[e.key]=true);
document.addEventListener("keyup",e=>keyState[e.key]=false);
function touchButton(id,key){
  const el=document.getElementById(id);
  el.addEventListener("touchstart",e=>{e.preventDefault();keyState[key]=true;},{passive:false});
  el.addEventListener("touchend",e=>{e.preventDefault();keyState[key]=false;},{passive:false});
  el.addEventListener("touchcancel",()=>{keyState[key]=false;});
}
touchButton("left","L");
touchButton("right","R");
touchButton("up","J");
touchButton("a","A");
touchButton("b","B");

// ステージ
const platforms = [
  {x:50,y:150,w:80,h:10},
  {x:200,y:120,w:100,h:10}
];

// プレイヤークラス
class Player{
  constructor(x,y,color){
    this.x=x; this.y=y;
    this.spawnX=x; this.spawnY=y;
    this.vx=0; this.vy=0;
    this.w=20; this.h=40;
    this.color=color;
    this.jumpCount=0;
    this.state="idle";
    this.attackTimer=0;
    this.attackType="weak";
    this.damage=0;
  }

  update(){
    if(this.state!=="attack"){
      if(keyState["L"]) this.vx=-3;
      else if(keyState["R"]) this.vx=3;
      else this.vx=0;
    }else{
      this.vx=0;
      this.attackTimer--;
      if(this.attackTimer<=0) this.state="idle";
    }

    // 二段ジャンプ
    if(keyState["J"] && this.jumpCount<2){
      this.vy=-10;
      this.jumpCount++;
      keyState["J"]=false;
    }

    // 攻撃
    const isDown = keyState["S"];
    if(keyState["A"] && this.state==="idle"){
      this.state="attack";
      this.attackTimer=14;
      this.attackType="weak";
      keyState["A"]=false;
    }
    if(keyState["B"] && this.state==="idle"){
      this.state="attack";
      this.attackTimer=24;
      this.attackType=isDown?"down":"forward";
      keyState["B"]=false;
    }
    if(keyState["J"] && keyState["A"] && this.state==="idle"){
      this.state="attack";
      this.attackTimer=16;
      this.attackType="air";
      keyState["A"]=false;
    }

    // 重力
    this.vy+=0.6;

    // 移動
    this.x+=this.vx;
    this.y+=this.vy;

    // 足場判定
    for(const p of platforms){
      if(this.vy>=0 && this.x+this.w>p.x && this.x<p.x+p.w &&
         this.y+this.h>=p.y && this.y+this.h<=p.y+p.h+10){
           this.y=p.y-this.h;
           this.vy=0;
           this.jumpCount=0;
      }
    }
    // 地面判定
    if(this.y+this.h>200){
      this.y=200-this.h;
      this.vy=0;
      this.jumpCount=0;
    }

    // 落下復活
    if(this.y>canvas.height){
      this.x=this.spawnX; this.y=this.spawnY;
      this.vx=0; this.vy=0; this.damage=0; this.jumpCount=0;
      this.state="idle";
    }
  }

  draw(){
    ctx.fillStyle=this.state==="attack"?"red":this.color;
    // 胴体
    ctx.fillRect(this.x,this.y,this.w,this.h);
    // 頭
    ctx.fillRect(this.x+4,this.y-10,this.w-8,10);
    // 手
    ctx.fillRect(this.x-4,this.y+4,4,this.h-8);
    ctx.fillRect(this.x+this.w,this.y+4,4,this.h-8);
    // 足
    ctx.fillRect(this.x+4,this.y+this.h,6,8);
    ctx.fillRect(this.x+this.w-10,this.y+this.h,6,8);
  }

  attackHit(target){
    if(this.state!=="attack") return;
    const dx=(this.x+this.w/2)-(target.x+target.w/2);
    const dy=(this.y+this.h/2)-(target.y+target.h/2);
    if(Math.abs(dx)<28 && Math.abs(dy)<40){
      let dmg=0,vx=0,vy=0;
      if(this.attackType==="air"){ dmg=8; vx=dx>0?-2:2; vy=-8; }
      else if(this.attackType==="down"){ dmg=10; vx=0; vy=8; }
      else{ dmg=12; vx=dx>0?-6:6; vy=-4; }
      target.damage+=dmg;
      const k=1+target.damage*0.02;
      target.vx=vx*k; target.vy=vy*k;
    }
  }
}

// CPUクラス
class CPU extends Player{
  constructor(x,y,color){ super(x,y,color); this.aiTimer=0; }
  update(player){
    this.aiTimer--;
    if(this.aiTimer<=0){
      this.aiTimer=30+Math.random()*40;
      const dx=player.x-this.x;
      if(Math.abs(dx)>50) this.vx=dx>0?2:-2;
      else this.vx=0;
      if(Math.random()<0.3 && this.jumpCount<2) this.vy=-10;
      if(this.state==="idle"){
        if(Math.abs(dx)<40){ this.state="attack"; this.attackType=Math.random()<0.5?"weak":"air"; this.attackTimer=this.attackType==="weak"?14:16; }
        else if(Math.abs(dx)<120){ this.state="attack"; this.attackType="forward"; this.attackTimer=24; }
      }
    }
    super.update();
    this.attackHit(player);
  }
}

// インスタンス作成
const player=new Player(80,150,"cyan");
const cpu=new CPU(260,150,"orange");

// 描画
function drawPlatforms(){
  ctx.fillStyle="#666";
  for(const p of platforms) ctx.fillRect(p.x,p.y,p.w,p.h);
}

// ゲームループ
function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // 地面
  ctx.fillStyle="#555";
  ctx.fillRect(0,200,360,40);
  drawPlatforms();

  cpu.update(player);
  player.update();
  player.attackHit(cpu);

  cpu.draw();
  player.draw();

  // ダメージ表示
  ctx.fillStyle="white";
  ctx.fillText("P:"+Math.floor(player.damage)+"%",10,20);
  ctx.fillText("CPU:"+Math.floor(cpu.damage)+"%",260,20);

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
