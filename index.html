<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Mini Smash Complete</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body{margin:0;background:#111;touch-action:none}
canvas{background:#222;display:block;margin:auto}
.ui{
  position:fixed;bottom:10px;left:0;right:0;
  display:flex;justify-content:space-between;padding:0 20px
}
.left,.right{display:flex;gap:10px}
button{
  width:64px;height:64px;border-radius:50%;
  font-size:18px;opacity:0.8
}
</style>
</head>
<body>

<canvas id="game" width="360" height="240"></canvas>

<div class="ui">
  <div class="left">
    <button id="l">◀</button>
    <button id="r">▶</button>
  </div>
  <div class="right">
    <button id="j">⬆</button>
    <button id="a">A</button>
    <button id="b">B</button>
  </div>
</div>

<script>
const c=document.getElementById("game"),ctx=c.getContext("2d");
const key={};

const bind=(id,k)=>{
  const e=document.getElementById(id);
  e.ontouchstart=()=>key[k]=true;
  e.ontouchend=()=>key[k]=false;
};
bind("l","L");bind("r","R");bind("j","J");bind("a","A");bind("b","B");

document.onkeydown=e=>key[e.key]=true;
document.onkeyup=e=>key[e.key]=false;

class Fighter{
  constructor(x,color,ai=false){
    this.x=x;this.y=150;
    this.vx=0;this.vy=0;
    this.w=22;this.h=44;
    this.dir=1;
    this.jump=0;
    this.state="idle";
    this.timer=0;
    this.damage=0;
    this.color=color;
    this.ai=ai;
    this.aiTimer=0;
  }

  control(enemy){
    if(this.ai){
      this.aiTimer--;
      const d=enemy.x-this.x;
      if(this.aiTimer<=0){
        this.aiTimer=30+Math.random()*40;
        if(Math.abs(d)>90){
          this.vx=d>0?2:-2;this.dir=this.vx>0?1:-1;
        }else{
          this.vx=0;
          if(Math.random()<0.6)this.attack(Math.random()<0.5?1:2,enemy);
          if(Math.random()<0.3&&this.jump<2)this.doJump();
        }
      }
      return;
    }

    if(this.state!=="attack"){
      if(key["L"]||key["a"]){this.vx=-3;this.dir=-1;}
      else if(key["R"]||key["d"]){this.vx=3;this.dir=1;}
      else this.vx=0;

      if((key["J"]||key["w"])&&this.jump<2)this.doJump();
      if(key["A"]||key[" "])this.attack(1,enemy);
      if(key["B"])this.attack(2,enemy);
    }
  }

  doJump(){
    this.vy=-10;
    this.jump++;
    this.state="jump";
  }

  attack(p,enemy){
    if(this.state==="attack")return;
    this.state="attack";
    this.timer=p===1?14:24;
    this.power=p;
    this.hitDone=false;
  }

  physics(){
    this.vy+=0.6;
    this.x+=this.vx;
    this.y+=this.vy;

    if(this.y+this.h>=200){
      this.y=200-this.h;
      this.vy=0;
      this.jump=0;
      if(this.state==="jump")this.state="idle";
    }

    if(this.state==="attack"){
      this.timer--;
      if(this.timer<=0)this.state="idle";
    }

    if(this.y>260){
      this.x=this.ai?260:80;
      this.y=0;
      this.damage=0;
    }
  }

  hit(enemy){
    if(this.state!=="attack"||this.hitDone)return;
    if(this.timer>6)return;

    const hx=this.x+this.dir*(this.w+10);
    if(Math.abs(hx-enemy.x)<28&&Math.abs(this.y-enemy.y)<40){
      const dmg=this.power===1?6:12;
      enemy.damage+=dmg;
      const k=1+enemy.damage*0.02;
      enemy.vx=this.dir*6*k;
      enemy.vy=-4*k;
      enemy.state="jump";
      enemy.hitDone=true;
    }
    this.hitDone=true;
  }

  draw(){
    ctx.fillStyle=this.state==="attack"?"red":this.color;
    ctx.fillRect(this.x,this.y,this.w,this.h);
    // 腕
    ctx.fillRect(this.x+this.dir*this.w,this.y+14,10,6);
  }
}

const p=new Fighter(80,"cyan");
const cpu=new Fighter(260,"orange",true);

function loop(){
  ctx.clearRect(0,0,360,240);
  ctx.fillStyle="#555";
  ctx.fillRect(0,200,360,40);

  p.control(cpu);
  cpu.control(p);

  p.physics();
  cpu.physics();

  p.hit(cpu);
  cpu.hit(p);

  p.draw();
  cpu.draw();

  ctx.fillStyle="white";
  ctx.fillText("P:"+Math.floor(p.damage)+"%",10,20);
  ctx.fillText("CPU:"+Math.floor(cpu.damage)+"%",260,20);

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
