<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>スマブラ風ゲーム 完全版</title>
<style>
canvas { background:#aaddff; display:block; margin:0 auto; touch-action:none; }
#stick,#jump,#attackA,#attackB{
  position:absolute; border-radius:50%; opacity:0.6; touch-action:none;
}
#stick{background:#8888ff;} #jump{background:#88ff88;} #attackA{background:#ff8888;} #attackB{background:#ff44ff;}
</style>
</head>
<body>

<canvas id="gameCanvas" width="480" height="320"></canvas>
<div id="stick" style="width:160px;height:160px;left:20px;bottom:20px;"></div>
<div id="jump"></div>
<div id="attackA"></div>
<div id="attackB"></div>

<script>
const canvas=document.getElementById("gameCanvas");
const ctx=canvas.getContext("2d");

// --- パーティクル ---
let particles=[];

// --- スコア & ラウンド管理 ---
let score={player:0,cpu:0}, roundOver=false, winner="";

// --- 足場 ---
const platforms=[
  {x:0,y:260,w:480,h:20},
  {x:120,y:180,w:120,h:15},
  {x:280,y:140,w:100,h:15},
  {x:50,y:100,w:80,h:15}
];

// --- プレイヤー ---
class Player{
  constructor(x,y,color,isCPU=false){
    this.x=x; this.y=y; this.spawnX=x; this.spawnY=y;
    this.color=color; this.isCPU=isCPU;
    this.w=32; this.h=40; this.vx=0; this.vy=0; 
    this.jumpCount=0; this.state="idle"; this.attackTimer=0;
    this.attackType=""; this.damage=0; this.hitFlash=0; this.hitBounce=0;
    this.respawnTimer=0;
  }

  update(target){
    if(!this.isCPU) this.x+=this.vx;
    this.vy+=0.6; this.y+=this.vy;

    // 足場判定
    platforms.forEach(p=>{
      if(this.vy>=0 &&
         this.x+this.w>p.x && this.x<p.x+p.w &&
         this.y+this.h>=p.y && this.y+this.h<=p.y+p.h+10){
           this.y=p.y-this.h;
           this.vy=0;
           this.jumpCount=0;
           if(this.state==="jump") this.state="idle";
      }
    });

    // 場外判定
    if(this.y+this.h>canvas.height || this.x+this.w<0 || this.x>canvas.width || this.y<-this.h){
        this.respawn();
    }

    // 攻撃判定
    if(target) this.attackHit(target);

    // 攻撃モーション管理
    if(this.attackTimer>0){ this.attackTimer--; this.state="attack"; }
    else if(this.state==="attack"){ this.state="idle"; }

    // ジャンプ/落下モーション
    if(this.vy<0) this.state="jump";
    if(this.vy>0 && !this.onGround()) this.state="fall";
  }

  attackHit(target){
    if(this.state!=="attack") return;
    const rangeX=40, rangeY=50;
    const dx=(this.x+this.w/2)-(target.x+target.w/2);
    const dy=(this.y+this.h/2)-(target.y+target.h/2);
    if(Math.abs(dx)<rangeX && Math.abs(dy)<rangeY){
        let dmg=0,vx=0,vy=0;
        const k=1+target.damage*0.03;
        switch(this.attackType){
            case "weak": dmg=8; vx=(dx>0?-4:4)*k; vy=-3; break;
            case "forward": dmg=12; vx=(dx>0?-6:6)*k; vy=-4; break;
            case "air": dmg=10; vx=(dx>0?-5:5)*k; vy=-5; break;
            case "down": dmg=14; vx=0; vy=6; break;
        }
        target.damage+=dmg;
        target.vx=vx; target.vy=vy;
        target.hitFlash=6; target.hitBounce=2;

        // 空中コンボ対応
        if(!target.onGround() && this.state==="attack"){ target.vy-=2; }

        // パーティクル生成
        for(let i=0;i<8;i++){
            particles.push({
                x: target.x+target.w/2,
                y: target.y+target.h/2,
                vx:(Math.random()-0.5)*4,
                vy:(Math.random()-0.5)*4,
                life:12
            });
        }
    }
  }

  draw(){
    if(this.respawnTimer>0){
        ctx.globalAlpha=0.5+0.05*(10-this.respawnTimer); this.respawnTimer--;
    } else ctx.globalAlpha=1;

    if(this.hitFlash>0){ ctx.fillStyle="orange"; this.hitFlash--; this.y-=this.hitBounce; }
    else ctx.fillStyle=this.state==="attack"?"red":this.color;

    // 胴体
    ctx.fillRect(this.x,this.y,this.w,this.h);
    // 頭
    ctx.fillRect(this.x+8,this.y-20,this.w-16,20);
    // 手足
    ctx.fillRect(this.x-8,this.y+8,8,this.h-16);
    ctx.fillRect(this.x+this.w,this.y+8,8,this.h-16);
    ctx.fillRect(this.x+8,this.y+this.h,12,16);
    ctx.fillRect(this.x+this.w-20,this.y+this.h,12,16);

    // ラベル
    ctx.fillStyle="white"; ctx.font="14px sans-serif";
    ctx.fillText(this.isCPU?"CPU":"P",this.x,this.y-25);

    ctx.globalAlpha=1;

    // パーティクル描画
    particles.forEach((p,i)=>{
        ctx.fillStyle="yellow";
        ctx.fillRect(p.x,p.y,4,4);
        p.x+=p.vx; p.y+=p.vy; p.life--;
        if(p.life<=0) particles.splice(i,1);
    });
  }

  respawn(){
    this.x=this.spawnX; this.y=this.spawnY; this.vx=0; this.vy=0;
    this.damage=0; this.jumpCount=0; this.state="idle"; this.respawnTimer=10;
    if(this.isCPU) score.player++;
    else score.cpu++;
  }

  onGround(){ return platforms.some(p=>this.y+this.h===p.y); }
}

// --- CPU ---
class CPU extends Player{
  constructor(x,y,color){ super(x,y,color,true); this.aiTimer=0; }
  update(player){
    this.aiTimer--;
    if(this.aiTimer<=0){
      this.aiTimer=25+Math.random()*35;
      const dx=player.x-this.x; const dy=player.y-this.y;
      if(Math.abs(dx)>50) this.vx=dx>0?2:-2; else this.vx=0;
      if(dy<-20 && this.jumpCount<2 && Math.random()<0.6){ this.vy=-10; this.jumpCount++; }
      if(this.state==="idle"){
        if(Math.abs(dx)<40 && Math.abs(dy)<50){ this.state="attack"; this.attackType=Math.random()<0.4?"weak":"air"; this.attackTimer=this.attackType==="weak"?14:16; }
        else if(Math.abs(dx)<120 && Math.random()<0.35){ this.state="attack"; this.attackType="forward"; this.attackTimer=24; }
        else if(Math.abs(dx)<60 && dy>20 && Math.random()<0.3){ this.state="attack"; this.attackType="down"; this.attackTimer=18; }
      }
    }
    super.update(player);
  }
}

// --- インスタンス ---
const player=new Player(60,220,"blue");
const cpu=new CPU(380,220,"green");

// --- UI ---
const stick=document.getElementById("stick");
const jump=document.getElementById("jump");
const attackA=document.getElementById("attackA");
const attackB=document.getElementById("attackB");

// ボタン配置
jump.style.width=jump.style.height="100px"; jump.style.bottom="160px"; jump.style.right="40px";
attackA.style.width=attackA.style.height="90px"; attackA.style.bottom="60px"; attackA.style.right="40px";
attackB.style.width=attackB.style.height="90px"; attackB.style.bottom="60px"; attackB.style.right="140px";

// スティック操作
let stickX=0,stickY=0;
const stickRadius=80;
const stickCenter={x:100,y:canvas.height-100};
stick.addEventListener('touchmove',e=>{
  const t=e.touches[0];
  let dx=t.clientX-stickCenter.x;
  let dy=t.clientY-stickCenter.y;
  const dist=Math.sqrt(dx*dx+dy*dy);
  if(dist>stickRadius){ dx=dx/dist*stickRadius; dy=dy/dist*stickRadius; }
  stickX=(dx/stickRadius)*1.2;
});
stick.addEventListener('touchend',e=>{ stickX=0; stickY=0; });

// ジャンプボタン
jump.addEventListener('touchstart',e=>{ if(player.jumpCount<2){ player.vy=-10; player.jumpCount++; } });

// 攻撃ボタン
attackA.addEventListener('touchstart',e=>{ if(player.state==="idle"){ player.state="attack"; player.attackType="weak"; player.attackTimer=14; } });
attackB.addEventListener('touchstart',e=>{ if(player.state==="idle"){ player.state="attack"; player.attackType="forward"; player.attackTimer=24; } });

// --- 描画 ---
function drawPlatforms(){ ctx.fillStyle="#555"; platforms.forEach(p=>ctx.fillRect(p.x,p.y,p.w,p.h)); }
function drawScore(){ ctx.fillStyle="black"; ctx.font="20px sans-serif"; ctx.fillText(`P: ${score.player}`,20,30); ctx.fillText(`CPU: ${score.cpu}`,380,30); }

// --- ラウンド判定 ---
function checkRound(){
  if(roundOver) return;
  if(score.player>=3 || score.cpu>=3){
      roundOver=true;
      winner = score.player>=3 ? "P" : "CPU";
      setTimeout(()=>{ 
          roundOver=false; score.player=0; score.cpu=0; 
          player.respawn(); cpu.respawn(); 
      }, 3000);
  }
}

// --- メインループ ---
function loop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawPlatforms();
    player.vx=stickX*4;
    player.update(cpu);
    cpu.update(player);
    player.draw();
    cpu.draw();
    drawScore();
    checkRound();

    if(roundOver){
        ctx.fillStyle="gold"; ctx.font="40px sans-serif";
        ctx.fillText(`${winner} WIN!`, canvas.width/2-70, canvas.height/2);
        if(winner==="P") player.hitFlash=10;
        else cpu.hitFlash=10;
    }

    requestAnimationFrame(loop);
}
loop();

</script>
</body>
</html>
